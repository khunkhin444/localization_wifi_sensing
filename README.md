# Passive WiFi CSI Indoor Localization (Private Research)

> **Status:** personal research repo (not for public release)  
> **Data:** proprietary (not included)  
> **Goal:** passive **2D localization (x, y)** from **raw WiFi CSI** (no AP control), including *Empty vs Occupied* as an auxiliary output.

---

## Overview

This project studies **passive indoor human localization** using **WiFi CSI** in challenging conditions (e.g., NLOS / through-wall).  
A multi-stage pipeline converts raw CSI into window tensors, extracts amplitude embeddings using a pretrained CNN (PreCNN), fuses phase/AoA features (PhaseFusing), fine-tunes for domain shift, then runs inference to predict continuous coordinates.

### Pipeline (run in order)

1. **PreCNN**  
2. **build_coords**  
3. **PhaseFusing**  
4. **Finetune**  
5. **Prediction**

Each stage depends on artifacts generated by previous stages.

---

## Hardware / Tooling Notes (my setup)

- **TX (in-room AP):** AX1500 (WiFi 6 / 802.11ax)  
- **RX:** Intel AX201 / AX211 (commodity WiFi 6 NICs)  
- **Band:** 5 GHz (e.g., 5180 MHz, Ch 36)  
- **CSI capture:** PicoScenes  
- **Traffic enrichment:** aircrack-ng (optional)  
- **Dataset:** not open-source

---

## Data Format

### Raw input
- PicoScenes `.csi` capture files

### Windowed output (produced by MATLAB preprocessing)
For each session:
```
<out>/<basename>/windows/
  amp_window_00001.npy   # [T_win x S_kept x A] float32
  pha_window_00001.npy   # [T_win x S_kept x A] float32 (radians, detrended)
  meta_00001.mat
  ...
```

### Preprocessing script (MATLAB)
I use a script like:
- `csi_build_clean_windows(...)`

What it does (high-level):
- Parse PicoScenes CSI
- CF/CBW filtering (optional)
- Windowing (WinSec/HopSec/MinFillRatio)
- Amplitude cleaning (Hampel + SG/wavelet)
- Phase unwrap + per-packet linear detrend + light temporal SG smoothing
- Save per-window amplitude/phase to `.npy` + metadata `.mat`

> If you change `WinSec`, `HopSec`, `TrimEdges`, `SubsampleStep`, you must keep them consistent for training/inference.

---

## Repo Structure (recommended)

```
.
├── matlab/
│   ├── csi_build_clean_windows.m
│   └── parseCSIFile.m
├── notebooks/ or src/
│   ├── 1_PreCNN.ipynb
│   ├── 2_build_coords.ipynb
│   ├── 3_PhaseFusing.ipynb
│   ├── 4_Finetune.ipynb
│   └── 5_Prediction.ipynb
├── models/
├── runs/
└── README.md
```

---

## Pipeline Details

### 1) PreCNN (Amplitude encoder)
**Input:** `amp_window_*.npy`  
**Output:** pretrained encoder (feature extractor)

- Train a CNN on **amplitude windows** to learn stable RF fingerprints.
- Save:
  - encoder weights (e.g., `models/prec_encoder.h5`)
  - (optional) classifier checkpoint/logs

**Artifacts needed for next steps:** encoder model file.

---

### 2) build_coords (Anchor coordinate mapping)
**Input:** window folders + your anchor mapping  
**Output:** coordinate labels + training lists

- Define anchor points (example):
  - `Left -> (0,0)`, `Top -> (5,0)`, etc.
- Export training arrays such as:
  - `amp_list_loc.npy` (paths)
  - `coords.npy` (x,y targets)

**Artifacts needed for next steps:** coordinate arrays + path list.

---

### 3) PhaseFusing (Amplitude + Phase/AoA fusion)
**Input:**
- PreCNN encoder (from step 1)
- amplitude windows + phase windows
- coordinate list (from step 2)

**Output:** fused multi-task model (presence + location)

What it does:
- Amplitude branch: `z_pre = PreCNN(amp_window)`
- Phase branch:
  - compute AoA features from phase differences **if A>=2**, else use phase-pattern fallback
- Fusion MLP to combine `[z_pre || z_phys]`
- Heads:
  - **Presence:** Empty vs Occupied
  - **Regression:** (x,y) (typically masked for empty)

**Artifacts needed for next steps:** fused model checkpoint.

---

### 4) Finetune (Domain adaptation)
**Input:** fused model (step 3)  
**Output:** final fine-tuned model

Two-phase training:
1. Freeze PreCNN encoder, train fusion + heads
2. Unfreeze top encoder layers with small LR

Save final model (example):
- `models/final_finetuned_model.h5`

---

### 5) Prediction (Inference)
**Input:** final model + new window folders  
**Output:** predicted `(x,y)` per window + optional plots / session aggregation

Typical inference logic:
- For each window:
  - predict presence prob + (x,y)
- Aggregate across a session:
  - median / weighted mean of (x,y)
  - optionally filter by presence confidence

---

## Minimal “How to Run” (my workflow)

1) **MATLAB:** export windows from raw CSI  
- Run `csi_build_clean_windows` → produces `amp_window_*.npy` / `pha_window_*.npy`

2) **Python / Notebook sequence:**  
- `1_PreCNN → 2_build_coords → 3_PhaseFusing → 4_Finetune → 5_Prediction`

---

## Notes / Pitfalls

- **AoA can be unstable** in strong multipath; fusion helps but do not assume AoA alone is reliable.
- Keep **subcarrier selection** (`TrimEdges`, `SubsampleStep`) consistent across train/test.
- If packet timestamps are missing, preprocessing may synthesize time using `AssumedPktRate`.
- Because the dataset is private, paths/configs are intentionally local and not generalized.

---

## License / Sharing

This repository is **private research** (no dataset included).  
Do not publish data, trained weights, or identifying environment details without review.
